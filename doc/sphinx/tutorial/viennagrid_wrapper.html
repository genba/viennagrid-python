

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.2. Using viennagrid.wrapper &mdash; ViennaGrid for Python 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ViennaGrid for Python 0.1.0 documentation" href="../index.html" />
    <link rel="up" title="3. Tutorials" href="../tutorial.html" />
    <link rel="next" title="4. API reference" href="../apiref.html" />
    <link rel="prev" title="3.1. Using viennagrid" href="viennagrid.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../apiref.html" title="4. API reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="viennagrid.html" title="3.1. Using viennagrid"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">ViennaGrid for Python 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../tutorial.html" accesskey="U">3. Tutorials</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="using-viennagrid-wrapper">
<h1>3.2. Using <a class="reference internal" href="../apiref/viennagrid_wrapper.html#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a><a class="headerlink" href="#using-viennagrid-wrapper" title="Permalink to this headline">¶</a></h1>
<p>A mesh in ViennaGrid is composed of <strong>cells</strong> which, in turn, are defined by their <strong>vertices</strong>. All of the objects that conform the mesh are stored in a container called <strong>domain</strong>. In addition, a domain may be subdivided into <strong>segments</strong>.</p>
<p>When a domain is defined, all the points that will act as vertices of any cells must be added to the domain. Then, a segmentation object can be created to specify how a domain should be subdivided, and cells can be created within the segments from the vertices that already belong to the domain.</p>
<p>Please, refer to <a class="reference external" href="http://viennagrid.sourceforge.net/viennagrid-manual-current.pdf">ViennaGrid&#8217;s PDF manual</a> for further information.</p>
<div class="section" id="choosing-the-appropriate-type-of-domain">
<h2>3.2.1. Choosing the appropriate type of domain<a class="headerlink" href="#choosing-the-appropriate-type-of-domain" title="Permalink to this headline">¶</a></h2>
<p>When using <a class="reference internal" href="../apiref/viennagrid_wrapper.html#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a>, as opposed to <a class="reference internal" href="../apiref/viennagrid.html#module-viennagrid" title="viennagrid: High-level classes for mesh representation"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid</span></tt></a>, you must take into account what type of points and domains you need to use. <em>ViennaGrid for Python</em> supports the following point types:</p>
<ul class="simple">
<li>cartesian 1D, 2D and 3D</li>
<li>cylindrical (3-dimensional)</li>
<li>polar (2-dimensional)</li>
<li>spherical (3-dimensional)</li>
</ul>
<p>all of them using double precision.</p>
<p>In addition, the type of cells (and, thus, of domains and segments) consists in the combination of any of the point types with any of the following topological elements:</p>
<ul class="simple">
<li>lines</li>
<li>triangles</li>
<li>quadrilaterals</li>
<li>tetrahedra</li>
</ul>
<p>Hence, you will have to choose what type of points and domains you are going to use depending on your application. In the <a class="reference internal" href="../apiref/viennagrid_wrapper.html"><em>API reference of viennagrid.wrapper</em></a>, you can consult more information on the classes available, but for the sake of this tutorial, please note that you have the following point types available:</p>
<ul class="simple">
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointCartesian1D" title="viennagrid.wrapper.PointCartesian1D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian1D</span></tt></a> for creating cartesian 1D points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointCartesian2D" title="viennagrid.wrapper.PointCartesian2D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian2D</span></tt></a> for creating cartesian 2D points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointCartesian3D" title="viennagrid.wrapper.PointCartesian3D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian3D</span></tt></a> for creating cartesian 3D points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointCylindrical3D" title="viennagrid.wrapper.PointCylindrical3D"><tt class="xref py py-class docutils literal"><span class="pre">PointCylindrical3D</span></tt></a> for creating cylindrical points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointPolar2D" title="viennagrid.wrapper.PointPolar2D"><tt class="xref py py-class docutils literal"><span class="pre">PointPolar2D</span></tt></a> for creating polar points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointSpherical3D" title="viennagrid.wrapper.PointSpherical3D"><tt class="xref py py-class docutils literal"><span class="pre">PointSpherical3D</span></tt></a> for creating spherical points</li>
</ul>
<p>and as many classes for domains, segments and cells as combinations there are of the types of cell with the different types of point. For example, for a triangular mesh, you have the following domain classes:</p>
<ul class="simple">
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Domain" title="viennagrid.wrapper.TriangularCartesian2D_Domain"><tt class="xref py py-class docutils literal"><span class="pre">TriangularCartesian2D_Domain</span></tt></a> for creating triangular domains of cartesian 2D points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian3D_Domain" title="viennagrid.wrapper.TriangularCartesian3D_Domain"><tt class="xref py py-class docutils literal"><span class="pre">TriangularCartesian3D_Domain</span></tt></a> for creating triangular domains of cartesian 3D points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCylindrical3D_Domain" title="viennagrid.wrapper.TriangularCylindrical3D_Domain"><tt class="xref py py-class docutils literal"><span class="pre">TriangularCylindrical3D_Domain</span></tt></a> for creating triangular domains of cylindrical points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularPolar2D_Domain" title="viennagrid.wrapper.TriangularPolar2D_Domain"><tt class="xref py py-class docutils literal"><span class="pre">TriangularPolar2D_Domain</span></tt></a> for creating triangular domains of polar points</li>
<li><a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularSpherical3D_Domain" title="viennagrid.wrapper.TriangularSpherical3D_Domain"><tt class="xref py py-class docutils literal"><span class="pre">TriangularSpherical3D_Domain</span></tt></a> for creating triangular domains of spherical points</li>
</ul>
</div>
<div class="section" id="defining-a-domain">
<h2>3.2.2. Defining a domain<a class="headerlink" href="#defining-a-domain" title="Permalink to this headline">¶</a></h2>
<p>For our example, we will consider the domain presented in chapter 4 of <a class="reference external" href="http://viennagrid.sourceforge.net/viennagrid-manual-current.pdf">ViennaGrid&#8217;s PDF manual</a>:</p>
<p>This domain is a triangular domain in the cartesian 2D space which contains 5 vertices and which is subdivided into 2 segments, whereas each segment has two cells.</p>
<p>We thus start by defining a triangular domain of cartesian 2D points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">viennagrid.wrapper</span> <span class="kn">import</span> <span class="n">TriangularCartesian2D_Domain</span> <span class="k">as</span> <span class="n">Domain</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="adding-vertices-to-a-domain">
<h2>3.2.3. Adding vertices to a domain<a class="headerlink" href="#adding-vertices-to-a-domain" title="Permalink to this headline">¶</a></h2>
<p>The next step would be to add to the domain the vertices that will form our cells. To see what vertices are contained in the domain, you can use the read-only attribute <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Domain.vertices" title="viennagrid.wrapper.TriangularCartesian2D_Domain.vertices"><tt class="xref py py-attr docutils literal"><span class="pre">vertices</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">vertices</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>If you run this code, you will get an empty list, as you have seen in the interpreter output above, because we haven&#8217;t added any vertices to the domain yet.</p>
<p>To add vertices, we need to import the appropriate type of point (in our case: <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.PointCartesian2D" title="viennagrid.wrapper.PointCartesian2D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian2D</span></tt></a>) and use the method <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Domain.make_vertex" title="viennagrid.wrapper.TriangularCartesian2D_Domain.make_vertex"><tt class="xref py py-meth docutils literal"><span class="pre">make_vertex()</span></tt></a>, which accepts as its only parameter the point you want to add as a vertex.</p>
<p>Let&#8217;s add to the domain all the vertices that we need to define our cells:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">viennagrid.wrapper</span> <span class="kn">import</span> <span class="n">PointCartesian2D</span> <span class="k">as</span> <span class="n">Point</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c"># Vertex with ID #0</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c"># Vertex with ID #1</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c"># Vertex with ID #2</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c"># Vertex with ID #3</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c"># Vertex with ID #4</span>
<span class="n">d</span><span class="o">.</span><span class="n">make_vertex</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c"># Vertex with ID #5</span>
</pre></div>
</div>
<p>When you add a vertex to the domain, the vertex gets a unique ID which corresponds to its index in the list of vertices of the domain, as the comments on the right side indicate.</p>
<p>Now that we&#8217;ve added vertices to our domain, we will get a non-empty list whenever we read the attribute <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Domain.vertices" title="viennagrid.wrapper.TriangularCartesian2D_Domain.vertices"><tt class="xref py py-attr docutils literal"><span class="pre">vertices</span></tt></a>. If you&#8217;ve followed the tutorial so far, you will get an output similar to this one (although the memory addresses of the objects may be different in your case):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">vertices</span>
<span class="go"> [&lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362c80&gt;,</span>
<span class="go">  &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362cf8&gt;,</span>
<span class="go">  &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362d70&gt;,</span>
<span class="go">  &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362de8&gt;,</span>
<span class="go">  &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362e60&gt;,</span>
<span class="go">  &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362ed8&gt;]</span>
</pre></div>
</div>
<p>Just for fun, you can attempt to get information on any of the vertices. For example, you could try to get the coordinates of the fourth vertex by doing this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">to_point</span><span class="p">()</span><span class="o">.</span><span class="n">coords</span>
<span class="go">[2.0, 1.0]</span>
</pre></div>
</div>
</div>
<div class="section" id="subdividing-a-domain-into-segments">
<h2>3.2.4. Subdividing a domain into segments<a class="headerlink" href="#subdividing-a-domain-into-segments" title="Permalink to this headline">¶</a></h2>
<p>Now that we have a domain and vertices in it, we proceed to create a segmentation object that will define how the domain is divided into segments. When we do this, we must tell the segmentation to what domain it will correspond:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">viennagrid.wrapper</span> <span class="kn">import</span> <span class="n">TriangularCartesian2D_Segmentation</span> <span class="k">as</span> <span class="n">Segmentation</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">Segmentation</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to what we did before with the vertices of the domain, we can get a list of the segments contained in a segmentation by using the attribute <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments" title="viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments"><tt class="xref py py-attr docutils literal"><span class="pre">segments</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">segments</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Like before, this will return an empty list, since we haven&#8217;t created any segments in the segmentation yet.</p>
<p>To create addittional segments in a segmentation, we use the method <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segmentation.make_segment" title="viennagrid.wrapper.TriangularCartesian2D_Segmentation.make_segment"><tt class="xref py py-meth docutils literal"><span class="pre">make_segment()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">seg0</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">make_segment</span><span class="p">()</span>
</pre></div>
</div>
<p>This method will create a new segment in the segmentation, and will return the newly created segment object.</p>
<p>We will proceed to create a second segment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">seg1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">make_segment</span><span class="p">()</span>
</pre></div>
</div>
<p>Now there should be two segments in our segmentation, which we can check by reading the attribute <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments" title="viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments"><tt class="xref py py-attr docutils literal"><span class="pre">segments</span></tt></a> again:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">segments</span>
<span class="go">[&lt;viennagrid.wrapper.TriangularCartesian2D_Segment object at 0x258cfc0&gt;,</span>
<span class="go"> &lt;viennagrid.wrapper.TriangularCartesian2D_Segment object at 0x258d880&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-cells-within-a-segment">
<h2>3.2.5. Creating cells within a segment<a class="headerlink" href="#creating-cells-within-a-segment" title="Permalink to this headline">¶</a></h2>
<p>To finish with domain setup, the only remaining step is to create cells from the vertices we&#8217;ve added and store the newly created cells in a segment within the domain. For that purpose, we use the method <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell" title="viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell"><tt class="xref py py-meth docutils literal"><span class="pre">make_cell()</span></tt></a>, passing as parameters the vertices that form the cell in the appropriate order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">seg0</span><span class="o">.</span><span class="n">make_cell</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="c"># Cell with vertices 0-1-5</span>
<span class="n">seg0</span><span class="o">.</span><span class="n">make_cell</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="c"># Cell with vertices 1-4-5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Please, note that you have to pass the vertices from the domain! It will not work if you pass vertices different than those in the domain!</p>
<p class="last">However, if you get the vertices from the domain and store them in other variables or pass them as parameters, it will still work, since the reference to the original vertex is preserved.</p>
</div>
<p>Thanks to <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell" title="viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell"><tt class="xref py py-meth docutils literal"><span class="pre">make_cell()</span></tt></a>, the cells are now created and stored in the segment. If you want, you can check that they&#8217;re there by reading the <a class="reference internal" href="../apiref/viennagrid_wrapper.html#viennagrid.wrapper.TriangularCartesian2D_Segment.cells" title="viennagrid.wrapper.TriangularCartesian2D_Segment.cells"><tt class="xref py py-attr docutils literal"><span class="pre">cells</span></tt></a> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seg0</span><span class="o">.</span><span class="n">cells</span>
<span class="go">[&lt;viennagrid.wrapper.TriangularCartesian2D_Cell object at 0x7f15f833d1a0&gt;,</span>
<span class="go"> &lt;viennagrid.wrapper.TriangularCartesian2D_Cell object at 0x7f15f833d4b0&gt;]</span>
</pre></div>
</div>
<p>Now, you could even ask what vertices form any of the cells stored within the segment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seg0</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>
<span class="go">[&lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f8362f50&gt;,</span>
<span class="go"> &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f836f050&gt;,</span>
<span class="go"> &lt;viennagrid.wrapper.PointCartesian2D object at 0x7f15f836f0c8&gt;]</span>
</pre></div>
</div>
<p>and even show the coordinates of the cell&#8217;s vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seg0</span><span class="o">.</span><span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">v</span><span class="o">.</span><span class="n">to_point</span><span class="p">()</span><span class="o">.</span><span class="n">coords</span>
<span class="gp">...</span>
<span class="go">[0.0, 0.0]</span>
<span class="go">[1.0, 0.0]</span>
<span class="go">[0.0, 1.0]</span>
</pre></div>
</div>
</div>
<div class="section" id="what-to-do-next">
<h2>3.2.6. What to do next<a class="headerlink" href="#what-to-do-next" title="Permalink to this headline">¶</a></h2>
<p>You can find code examples on how to use <a class="reference internal" href="../apiref/viennagrid_wrapper.html#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a> in the source code of ViennaGrid for Python, under the directory <cite>doc/examples/viennagrid_wrapper/</cite>.</p>
<p>Once you have your domain set up, you can apply to it any algorithm from <a class="reference internal" href="../apiref/viennagrid_wrapper.html#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a>, associate scalar quantities to elements of the domain using accessors, or write the domain to a mesh file for data persistence with the I/O functions from <a class="reference internal" href="../apiref/viennagrid_wrapper.html#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a>. For more information on how to use them, take a look at the <a class="reference internal" href="../apiref/viennagrid_wrapper.html"><em>API reference of viennagrid.wrapper</em></a> and the aforementioned code examples.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2. Using <tt class="docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a><ul>
<li><a class="reference internal" href="#choosing-the-appropriate-type-of-domain">3.2.1. Choosing the appropriate type of domain</a></li>
<li><a class="reference internal" href="#defining-a-domain">3.2.2. Defining a domain</a></li>
<li><a class="reference internal" href="#adding-vertices-to-a-domain">3.2.3. Adding vertices to a domain</a></li>
<li><a class="reference internal" href="#subdividing-a-domain-into-segments">3.2.4. Subdividing a domain into segments</a></li>
<li><a class="reference internal" href="#creating-cells-within-a-segment">3.2.5. Creating cells within a segment</a></li>
<li><a class="reference internal" href="#what-to-do-next">3.2.6. What to do next</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="viennagrid.html"
                        title="previous chapter">3.1. Using <tt class="docutils literal docutils literal docutils literal"><span class="pre">viennagrid</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../apiref.html"
                        title="next chapter">4. API reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/tutorial/viennagrid_wrapper.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../apiref.html" title="4. API reference"
             >next</a> |</li>
        <li class="right" >
          <a href="viennagrid.html" title="3.1. Using viennagrid"
             >previous</a> |</li>
        <li><a href="../index.html">ViennaGrid for Python 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../tutorial.html" >3. Tutorials</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Jonan Cruz-Martin.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>