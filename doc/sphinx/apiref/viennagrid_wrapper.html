

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.2. API reference of viennagrid.wrapper &mdash; ViennaGrid for Python 0.1.0-rc.4 documentation</title>
    
    <link rel="stylesheet" href="../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0-rc.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ViennaGrid for Python 0.1.0-rc.4 documentation" href="../index.html" />
    <link rel="up" title="4. API reference" href="../apiref.html" />
    <link rel="next" title="5. Developer’s guide" href="../devguide.html" />
    <link rel="prev" title="4.1. API reference of viennagrid" href="viennagrid.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../devguide.html" title="5. Developer’s guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="viennagrid.html" title="4.1. API reference of viennagrid"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">ViennaGrid for Python 0.1.0-rc.4 documentation</a> &raquo;</li>
          <li><a href="../apiref.html" accesskey="U">4. API reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-viennagrid.wrapper">
<span id="api-reference-of-viennagrid-wrapper"></span><h1>4.2. API reference of <a class="reference internal" href="#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a><a class="headerlink" href="#module-viennagrid.wrapper" title="Permalink to this headline">¶</a></h1>
<div class="section" id="points">
<h2>4.2.1. Points<a class="headerlink" href="#points" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-viennagrid.wrapper" title="viennagrid.wrapper: Python wrapper around ViennaGrid that provides low-level access to ViennaGrid's functions and classes"><tt class="xref py py-mod docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a> supports the following point types:</p>
<ul class="simple">
<li>cartesian 1D, 2D and 3D</li>
<li>cylindrical (3-dimensional)</li>
<li>polar (2-dimensional)</li>
<li>spherical (3-dimensional)</li>
</ul>
<p>all of them using double precision.</p>
<p>For each type of point there is a separate class:</p>
<ul class="simple">
<li><a class="reference internal" href="#viennagrid.wrapper.PointCartesian1D" title="viennagrid.wrapper.PointCartesian1D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian1D</span></tt></a> for creating cartesian 1D points</li>
<li><a class="reference internal" href="#viennagrid.wrapper.PointCartesian2D" title="viennagrid.wrapper.PointCartesian2D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian2D</span></tt></a> for creating cartesian 2D points</li>
<li><a class="reference internal" href="#viennagrid.wrapper.PointCartesian3D" title="viennagrid.wrapper.PointCartesian3D"><tt class="xref py py-class docutils literal"><span class="pre">PointCartesian3D</span></tt></a> for creating cartesian 3D points</li>
<li><a class="reference internal" href="#viennagrid.wrapper.PointCylindrical3D" title="viennagrid.wrapper.PointCylindrical3D"><tt class="xref py py-class docutils literal"><span class="pre">PointCylindrical3D</span></tt></a> for creating cylindrical points</li>
<li><a class="reference internal" href="#viennagrid.wrapper.PointPolar2D" title="viennagrid.wrapper.PointPolar2D"><tt class="xref py py-class docutils literal"><span class="pre">PointPolar2D</span></tt></a> for creating polar points</li>
<li><a class="reference internal" href="#viennagrid.wrapper.PointSpherical3D" title="viennagrid.wrapper.PointSpherical3D"><tt class="xref py py-class docutils literal"><span class="pre">PointSpherical3D</span></tt></a> for creating spherical points</li>
</ul>
<dl class="class">
<dt id="viennagrid.wrapper.PointCartesian1D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointCartesian1D</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian1D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian1D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian1D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointCartesian1D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointCartesian1D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.inner_prod">
<tt class="descname">inner_prod</tt><big>(</big><em>(PointCartesian1D)arg1</em>, <em>(PointCartesian1D)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.inner_prod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double inner_prod(PointCartesian1D {lvalue},PointCartesian1D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointCartesian1D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointCartesian1D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointCartesian1D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointCartesian1D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointCartesian1D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointCartesian1D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian1D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointCartesian1D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian1D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointCartesian1D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.PointCartesian2D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointCartesian2D</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian2D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian2D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian2D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointCartesian2D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointCartesian2D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.inner_prod">
<tt class="descname">inner_prod</tt><big>(</big><em>(PointCartesian2D)arg1</em>, <em>(PointCartesian2D)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.inner_prod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double inner_prod(PointCartesian2D {lvalue},PointCartesian2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointCartesian2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointCartesian2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointCartesian2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointCartesian2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointCartesian2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointCartesian2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointCartesian2D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointCartesian2D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian2D.to_polar">
<tt class="descname">to_polar</tt><big>(</big><em>(PointCartesian2D)arg1</em><big>)</big> &rarr; PointPolar2D :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian2D.to_polar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D to_polar(PointCartesian2D {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.PointCartesian3D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointCartesian3D</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian3D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian3D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.cross_prod">
<tt class="descname">cross_prod</tt><big>(</big><em>(PointCartesian3D)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.cross_prod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D cross_prod(PointCartesian3D {lvalue},PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCartesian3D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointCartesian3D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointCartesian3D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.inner_prod">
<tt class="descname">inner_prod</tt><big>(</big><em>(PointCartesian3D)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.inner_prod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double inner_prod(PointCartesian3D {lvalue},PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointCartesian3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointCartesian3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointCartesian3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointCartesian3D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointCartesian3D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.to_cylindrical">
<tt class="descname">to_cylindrical</tt><big>(</big><em>(PointCartesian3D)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.to_cylindrical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_cylindrical(PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCartesian3D.to_spherical">
<tt class="descname">to_spherical</tt><big>(</big><em>(PointCartesian3D)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.PointCartesian3D.to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_spherical(PointCartesian3D {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.PointCylindrical3D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointCylindrical3D</tt><a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointCylindrical3D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCylindrical3D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointCylindrical3D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointCylindrical3D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointCylindrical3D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointCylindrical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointCylindrical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointCylindrical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointCylindrical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointCylindrical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointCylindrical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointCylindrical3D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointCylindrical3D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.to_cartesian">
<tt class="descname">to_cartesian</tt><big>(</big><em>(PointCylindrical3D)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_cartesian(PointCylindrical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointCylindrical3D.to_spherical">
<tt class="descname">to_spherical</tt><big>(</big><em>(PointCylindrical3D)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.PointCylindrical3D.to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_spherical(PointCylindrical3D {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.PointPolar2D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointPolar2D</tt><a class="headerlink" href="#viennagrid.wrapper.PointPolar2D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointPolar2D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointPolar2D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointPolar2D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointPolar2D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointPolar2D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointPolar2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointPolar2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointPolar2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointPolar2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointPolar2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointPolar2D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointPolar2D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointPolar2D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointPolar2D.to_cartesian">
<tt class="descname">to_cartesian</tt><big>(</big><em>(PointPolar2D)arg1</em><big>)</big> &rarr; PointCartesian2D :<a class="headerlink" href="#viennagrid.wrapper.PointPolar2D.to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D to_cartesian(PointPolar2D {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.PointSpherical3D">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">PointSpherical3D</tt><a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.PointSpherical3D.coord_system">
<tt class="descname">coord_system</tt><a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.coord_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the coordinate system of the space where the point is defined.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointSpherical3D.coords">
<tt class="descname">coords</tt><a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the coordinates of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.PointSpherical3D.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the dimension of the space where the point is defined.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.get_coord">
<tt class="descname">get_coord</tt><big>(</big><em>(PointSpherical3D)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.get_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double get_coord(PointSpherical3D {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.norm_1">
<tt class="descname">norm_1</tt><big>(</big><em>(PointSpherical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.norm_1" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_1(PointSpherical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.norm_2">
<tt class="descname">norm_2</tt><big>(</big><em>(PointSpherical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.norm_2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_2(PointSpherical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.norm_inf">
<tt class="descname">norm_inf</tt><big>(</big><em>(PointSpherical3D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>double norm_inf(PointSpherical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.set_coord">
<tt class="descname">set_coord</tt><big>(</big><em>(PointSpherical3D)arg1</em>, <em>(int)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.set_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the coordinate at given index in the coordinate list.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void set_coord(PointSpherical3D {lvalue},unsigned int,double)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.to_cartesian">
<tt class="descname">to_cartesian</tt><big>(</big><em>(PointSpherical3D)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_cartesian(PointSpherical3D {lvalue})</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.PointSpherical3D.to_cylindrical">
<tt class="descname">to_cylindrical</tt><big>(</big><em>(PointSpherical3D)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.PointSpherical3D.to_cylindrical" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_cylindrical(PointSpherical3D {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="domains">
<h2>4.2.2. Domains<a class="headerlink" href="#domains" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearCartesian1D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian1D_Vertex get_vertex(LinearCartesian1D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em>, <em>(LinearCartesian1D_Vertex)arg2</em>, <em>(LinearCartesian1D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian1D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian1D_Cell make_cell(LinearCartesian1D_Domain {lvalue},LinearCartesian1D_Vertex,LinearCartesian1D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em>, <em>(PointCartesian1D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearCartesian1D_Domain {lvalue},PointCartesian1D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearCartesian2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearCartesian2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian2D_Vertex get_vertex(LinearCartesian2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian2D_Domain)arg1</em>, <em>(LinearCartesian2D_Vertex)arg2</em>, <em>(LinearCartesian2D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian2D_Cell make_cell(LinearCartesian2D_Domain {lvalue},LinearCartesian2D_Vertex,LinearCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearCartesian2D_Domain)arg1</em>, <em>(PointCartesian2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearCartesian2D_Domain {lvalue},PointCartesian2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearCartesian3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearCartesian3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian3D_Vertex get_vertex(LinearCartesian3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian3D_Domain)arg1</em>, <em>(LinearCartesian3D_Vertex)arg2</em>, <em>(LinearCartesian3D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian3D_Cell make_cell(LinearCartesian3D_Domain {lvalue},LinearCartesian3D_Vertex,LinearCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearCartesian3D_Domain)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearCartesian3D_Domain {lvalue},PointCartesian3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearCylindrical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearCylindrical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCylindrical3D_Vertex get_vertex(LinearCylindrical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCylindrical3D_Domain)arg1</em>, <em>(LinearCylindrical3D_Vertex)arg2</em>, <em>(LinearCylindrical3D_Vertex)arg3</em><big>)</big> &rarr; LinearCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCylindrical3D_Cell make_cell(LinearCylindrical3D_Domain {lvalue},LinearCylindrical3D_Vertex,LinearCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearCylindrical3D_Domain)arg1</em>, <em>(PointCylindrical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearCylindrical3D_Domain {lvalue},PointCylindrical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearPolar2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearPolar2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearPolar2D_Vertex get_vertex(LinearPolar2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearPolar2D_Domain)arg1</em>, <em>(LinearPolar2D_Vertex)arg2</em>, <em>(LinearPolar2D_Vertex)arg3</em><big>)</big> &rarr; LinearPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearPolar2D_Cell make_cell(LinearPolar2D_Domain {lvalue},LinearPolar2D_Vertex,LinearPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearPolar2D_Domain)arg1</em>, <em>(PointPolar2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearPolar2D_Domain {lvalue},PointPolar2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(LinearSpherical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; LinearSpherical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearSpherical3D_Vertex get_vertex(LinearSpherical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearSpherical3D_Domain)arg1</em>, <em>(LinearSpherical3D_Vertex)arg2</em>, <em>(LinearSpherical3D_Vertex)arg3</em><big>)</big> &rarr; LinearSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearSpherical3D_Cell make_cell(LinearSpherical3D_Domain {lvalue},LinearSpherical3D_Vertex,LinearSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(LinearSpherical3D_Domain)arg1</em>, <em>(PointSpherical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(LinearSpherical3D_Domain {lvalue},PointSpherical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TriangularCartesian2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian2D_Vertex get_vertex(TriangularCartesian2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(TriangularCartesian2D_Vertex)arg2</em>, <em>(TriangularCartesian2D_Vertex)arg3</em>, <em>(TriangularCartesian2D_Vertex)arg4</em><big>)</big> &rarr; TriangularCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian2D_Cell make_cell(TriangularCartesian2D_Domain {lvalue},TriangularCartesian2D_Vertex,TriangularCartesian2D_Vertex,TriangularCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(PointCartesian2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TriangularCartesian2D_Domain {lvalue},PointCartesian2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TriangularCartesian3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TriangularCartesian3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian3D_Vertex get_vertex(TriangularCartesian3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCartesian3D_Domain)arg1</em>, <em>(TriangularCartesian3D_Vertex)arg2</em>, <em>(TriangularCartesian3D_Vertex)arg3</em>, <em>(TriangularCartesian3D_Vertex)arg4</em><big>)</big> &rarr; TriangularCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian3D_Cell make_cell(TriangularCartesian3D_Domain {lvalue},TriangularCartesian3D_Vertex,TriangularCartesian3D_Vertex,TriangularCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TriangularCartesian3D_Domain)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TriangularCartesian3D_Domain {lvalue},PointCartesian3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TriangularCylindrical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TriangularCylindrical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCylindrical3D_Vertex get_vertex(TriangularCylindrical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCylindrical3D_Domain)arg1</em>, <em>(TriangularCylindrical3D_Vertex)arg2</em>, <em>(TriangularCylindrical3D_Vertex)arg3</em>, <em>(TriangularCylindrical3D_Vertex)arg4</em><big>)</big> &rarr; TriangularCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCylindrical3D_Cell make_cell(TriangularCylindrical3D_Domain {lvalue},TriangularCylindrical3D_Vertex,TriangularCylindrical3D_Vertex,TriangularCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TriangularCylindrical3D_Domain)arg1</em>, <em>(PointCylindrical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TriangularCylindrical3D_Domain {lvalue},PointCylindrical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TriangularPolar2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TriangularPolar2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularPolar2D_Vertex get_vertex(TriangularPolar2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularPolar2D_Domain)arg1</em>, <em>(TriangularPolar2D_Vertex)arg2</em>, <em>(TriangularPolar2D_Vertex)arg3</em>, <em>(TriangularPolar2D_Vertex)arg4</em><big>)</big> &rarr; TriangularPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularPolar2D_Cell make_cell(TriangularPolar2D_Domain {lvalue},TriangularPolar2D_Vertex,TriangularPolar2D_Vertex,TriangularPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TriangularPolar2D_Domain)arg1</em>, <em>(PointPolar2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TriangularPolar2D_Domain {lvalue},PointPolar2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TriangularSpherical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TriangularSpherical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularSpherical3D_Vertex get_vertex(TriangularSpherical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularSpherical3D_Domain)arg1</em>, <em>(TriangularSpherical3D_Vertex)arg2</em>, <em>(TriangularSpherical3D_Vertex)arg3</em>, <em>(TriangularSpherical3D_Vertex)arg4</em><big>)</big> &rarr; TriangularSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularSpherical3D_Cell make_cell(TriangularSpherical3D_Domain {lvalue},TriangularSpherical3D_Vertex,TriangularSpherical3D_Vertex,TriangularSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TriangularSpherical3D_Domain)arg1</em>, <em>(PointSpherical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TriangularSpherical3D_Domain {lvalue},PointSpherical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(QuadrilateralCartesian2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; QuadrilateralCartesian2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian2D_Vertex get_vertex(QuadrilateralCartesian2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCartesian2D_Domain)arg1</em>, <em>(QuadrilateralCartesian2D_Vertex)arg2</em>, <em>(QuadrilateralCartesian2D_Vertex)arg3</em>, <em>(QuadrilateralCartesian2D_Vertex)arg4</em>, <em>(QuadrilateralCartesian2D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian2D_Cell make_cell(QuadrilateralCartesian2D_Domain {lvalue},QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(QuadrilateralCartesian2D_Domain)arg1</em>, <em>(PointCartesian2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(QuadrilateralCartesian2D_Domain {lvalue},PointCartesian2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(QuadrilateralCartesian3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; QuadrilateralCartesian3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian3D_Vertex get_vertex(QuadrilateralCartesian3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCartesian3D_Domain)arg1</em>, <em>(QuadrilateralCartesian3D_Vertex)arg2</em>, <em>(QuadrilateralCartesian3D_Vertex)arg3</em>, <em>(QuadrilateralCartesian3D_Vertex)arg4</em>, <em>(QuadrilateralCartesian3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian3D_Cell make_cell(QuadrilateralCartesian3D_Domain {lvalue},QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(QuadrilateralCartesian3D_Domain)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(QuadrilateralCartesian3D_Domain {lvalue},PointCartesian3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(QuadrilateralCylindrical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; QuadrilateralCylindrical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCylindrical3D_Vertex get_vertex(QuadrilateralCylindrical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCylindrical3D_Domain)arg1</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg2</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg3</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg4</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCylindrical3D_Cell make_cell(QuadrilateralCylindrical3D_Domain {lvalue},QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(QuadrilateralCylindrical3D_Domain)arg1</em>, <em>(PointCylindrical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(QuadrilateralCylindrical3D_Domain {lvalue},PointCylindrical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(QuadrilateralPolar2D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; QuadrilateralPolar2D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralPolar2D_Vertex get_vertex(QuadrilateralPolar2D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralPolar2D_Domain)arg1</em>, <em>(QuadrilateralPolar2D_Vertex)arg2</em>, <em>(QuadrilateralPolar2D_Vertex)arg3</em>, <em>(QuadrilateralPolar2D_Vertex)arg4</em>, <em>(QuadrilateralPolar2D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralPolar2D_Cell make_cell(QuadrilateralPolar2D_Domain {lvalue},QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(QuadrilateralPolar2D_Domain)arg1</em>, <em>(PointPolar2D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(QuadrilateralPolar2D_Domain {lvalue},PointPolar2D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(QuadrilateralSpherical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; QuadrilateralSpherical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralSpherical3D_Vertex get_vertex(QuadrilateralSpherical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralSpherical3D_Domain)arg1</em>, <em>(QuadrilateralSpherical3D_Vertex)arg2</em>, <em>(QuadrilateralSpherical3D_Vertex)arg3</em>, <em>(QuadrilateralSpherical3D_Vertex)arg4</em>, <em>(QuadrilateralSpherical3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralSpherical3D_Cell make_cell(QuadrilateralSpherical3D_Domain {lvalue},QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(QuadrilateralSpherical3D_Domain)arg1</em>, <em>(PointSpherical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(QuadrilateralSpherical3D_Domain {lvalue},PointSpherical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TetrahedralCartesian3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TetrahedralCartesian3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCartesian3D_Vertex get_vertex(TetrahedralCartesian3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralCartesian3D_Domain)arg1</em>, <em>(TetrahedralCartesian3D_Vertex)arg2</em>, <em>(TetrahedralCartesian3D_Vertex)arg3</em>, <em>(TetrahedralCartesian3D_Vertex)arg4</em>, <em>(TetrahedralCartesian3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCartesian3D_Cell make_cell(TetrahedralCartesian3D_Domain {lvalue},TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TetrahedralCartesian3D_Domain)arg1</em>, <em>(PointCartesian3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TetrahedralCartesian3D_Domain {lvalue},PointCartesian3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TetrahedralCylindrical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TetrahedralCylindrical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCylindrical3D_Vertex get_vertex(TetrahedralCylindrical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralCylindrical3D_Domain)arg1</em>, <em>(TetrahedralCylindrical3D_Vertex)arg2</em>, <em>(TetrahedralCylindrical3D_Vertex)arg3</em>, <em>(TetrahedralCylindrical3D_Vertex)arg4</em>, <em>(TetrahedralCylindrical3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCylindrical3D_Cell make_cell(TetrahedralCylindrical3D_Domain {lvalue},TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TetrahedralCylindrical3D_Domain)arg1</em>, <em>(PointCylindrical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TetrahedralCylindrical3D_Domain {lvalue},PointCylindrical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Domain</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the domain.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.get_vertex">
<tt class="descname">get_vertex</tt><big>(</big><em>(TetrahedralSpherical3D_Domain)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; TetrahedralSpherical3D_Vertex :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.get_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex with the given unique ID (which was assigned when the vertex was added either to the domain or to a segment contained in the domain).</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralSpherical3D_Vertex get_vertex(TetrahedralSpherical3D_Domain {lvalue},unsigned int)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralSpherical3D_Domain)arg1</em>, <em>(TetrahedralSpherical3D_Vertex)arg2</em>, <em>(TetrahedralSpherical3D_Vertex)arg3</em>, <em>(TetrahedralSpherical3D_Vertex)arg4</em>, <em>(TetrahedralSpherical3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the domain, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralSpherical3D_Cell make_cell(TetrahedralSpherical3D_Domain {lvalue},TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.make_vertex">
<tt class="descname">make_vertex</tt><big>(</big><em>(TetrahedralSpherical3D_Domain)arg1</em>, <em>(PointSpherical3D)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.make_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vertex to the domain. This gives the vertex a unique ID.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void make_vertex(TetrahedralSpherical3D_Domain {lvalue},PointSpherical3D)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices in the domain.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Domain.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Domain.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices in the domain.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="segmentations">
<h2>4.2.3. Segmentations<a class="headerlink" href="#segmentations" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearCartesian1D_Segmentation)arg1</em><big>)</big> &rarr; LinearCartesian1D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian1D_Segment make_segment(LinearCartesian1D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearCartesian2D_Segmentation)arg1</em><big>)</big> &rarr; LinearCartesian2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian2D_Segment make_segment(LinearCartesian2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearCartesian3D_Segmentation)arg1</em><big>)</big> &rarr; LinearCartesian3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian3D_Segment make_segment(LinearCartesian3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearCylindrical3D_Segmentation)arg1</em><big>)</big> &rarr; LinearCylindrical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCylindrical3D_Segment make_segment(LinearCylindrical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearPolar2D_Segmentation)arg1</em><big>)</big> &rarr; LinearPolar2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearPolar2D_Segment make_segment(LinearPolar2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(LinearSpherical3D_Segmentation)arg1</em><big>)</big> &rarr; LinearSpherical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearSpherical3D_Segment make_segment(LinearSpherical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TriangularCartesian2D_Segmentation)arg1</em><big>)</big> &rarr; TriangularCartesian2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian2D_Segment make_segment(TriangularCartesian2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TriangularCartesian3D_Segmentation)arg1</em><big>)</big> &rarr; TriangularCartesian3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian3D_Segment make_segment(TriangularCartesian3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TriangularCylindrical3D_Segmentation)arg1</em><big>)</big> &rarr; TriangularCylindrical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCylindrical3D_Segment make_segment(TriangularCylindrical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TriangularPolar2D_Segmentation)arg1</em><big>)</big> &rarr; TriangularPolar2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularPolar2D_Segment make_segment(TriangularPolar2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TriangularSpherical3D_Segmentation)arg1</em><big>)</big> &rarr; TriangularSpherical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularSpherical3D_Segment make_segment(TriangularSpherical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(QuadrilateralCartesian2D_Segmentation)arg1</em><big>)</big> &rarr; QuadrilateralCartesian2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian2D_Segment make_segment(QuadrilateralCartesian2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(QuadrilateralCartesian3D_Segmentation)arg1</em><big>)</big> &rarr; QuadrilateralCartesian3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian3D_Segment make_segment(QuadrilateralCartesian3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(QuadrilateralCylindrical3D_Segmentation)arg1</em><big>)</big> &rarr; QuadrilateralCylindrical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCylindrical3D_Segment make_segment(QuadrilateralCylindrical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(QuadrilateralPolar2D_Segmentation)arg1</em><big>)</big> &rarr; QuadrilateralPolar2D_Segment :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralPolar2D_Segment make_segment(QuadrilateralPolar2D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(QuadrilateralSpherical3D_Segmentation)arg1</em><big>)</big> &rarr; QuadrilateralSpherical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralSpherical3D_Segment make_segment(QuadrilateralSpherical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TetrahedralCartesian3D_Segmentation)arg1</em><big>)</big> &rarr; TetrahedralCartesian3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCartesian3D_Segment make_segment(TetrahedralCartesian3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TetrahedralCylindrical3D_Segmentation)arg1</em><big>)</big> &rarr; TetrahedralCylindrical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCylindrical3D_Segment make_segment(TetrahedralCylindrical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segmentation">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Segmentation</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.make_segment">
<tt class="descname">make_segment</tt><big>(</big><em>(TetrahedralSpherical3D_Segmentation)arg1</em><big>)</big> &rarr; TetrahedralSpherical3D_Segment :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.make_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new segment in the segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralSpherical3D_Segment make_segment(TetrahedralSpherical3D_Segmentation {lvalue})</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.num_segments">
<tt class="descname">num_segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.num_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of segments in the segmentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.segments">
<tt class="descname">segments</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segmentation.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the segments in the segmentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="segments">
<h2>4.2.4. Segments<a class="headerlink" href="#segments" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian1D_Segment)arg1</em>, <em>(LinearCartesian1D_Vertex)arg2</em>, <em>(LinearCartesian1D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian1D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian1D_Cell make_cell(LinearCartesian1D_Segment {lvalue},LinearCartesian1D_Vertex,LinearCartesian1D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian2D_Segment)arg1</em>, <em>(LinearCartesian2D_Vertex)arg2</em>, <em>(LinearCartesian2D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian2D_Cell make_cell(LinearCartesian2D_Segment {lvalue},LinearCartesian2D_Vertex,LinearCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCartesian3D_Segment)arg1</em>, <em>(LinearCartesian3D_Vertex)arg2</em>, <em>(LinearCartesian3D_Vertex)arg3</em><big>)</big> &rarr; LinearCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCartesian3D_Cell make_cell(LinearCartesian3D_Segment {lvalue},LinearCartesian3D_Vertex,LinearCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearCylindrical3D_Segment)arg1</em>, <em>(LinearCylindrical3D_Vertex)arg2</em>, <em>(LinearCylindrical3D_Vertex)arg3</em><big>)</big> &rarr; LinearCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearCylindrical3D_Cell make_cell(LinearCylindrical3D_Segment {lvalue},LinearCylindrical3D_Vertex,LinearCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearPolar2D_Segment)arg1</em>, <em>(LinearPolar2D_Vertex)arg2</em>, <em>(LinearPolar2D_Vertex)arg3</em><big>)</big> &rarr; LinearPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearPolar2D_Cell make_cell(LinearPolar2D_Segment {lvalue},LinearPolar2D_Vertex,LinearPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(LinearSpherical3D_Segment)arg1</em>, <em>(LinearSpherical3D_Vertex)arg2</em>, <em>(LinearSpherical3D_Vertex)arg3</em><big>)</big> &rarr; LinearSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>LinearSpherical3D_Cell make_cell(LinearSpherical3D_Segment {lvalue},LinearSpherical3D_Vertex,LinearSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCartesian2D_Segment)arg1</em>, <em>(TriangularCartesian2D_Vertex)arg2</em>, <em>(TriangularCartesian2D_Vertex)arg3</em>, <em>(TriangularCartesian2D_Vertex)arg4</em><big>)</big> &rarr; TriangularCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian2D_Cell make_cell(TriangularCartesian2D_Segment {lvalue},TriangularCartesian2D_Vertex,TriangularCartesian2D_Vertex,TriangularCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCartesian3D_Segment)arg1</em>, <em>(TriangularCartesian3D_Vertex)arg2</em>, <em>(TriangularCartesian3D_Vertex)arg3</em>, <em>(TriangularCartesian3D_Vertex)arg4</em><big>)</big> &rarr; TriangularCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCartesian3D_Cell make_cell(TriangularCartesian3D_Segment {lvalue},TriangularCartesian3D_Vertex,TriangularCartesian3D_Vertex,TriangularCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularCylindrical3D_Segment)arg1</em>, <em>(TriangularCylindrical3D_Vertex)arg2</em>, <em>(TriangularCylindrical3D_Vertex)arg3</em>, <em>(TriangularCylindrical3D_Vertex)arg4</em><big>)</big> &rarr; TriangularCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularCylindrical3D_Cell make_cell(TriangularCylindrical3D_Segment {lvalue},TriangularCylindrical3D_Vertex,TriangularCylindrical3D_Vertex,TriangularCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularPolar2D_Segment)arg1</em>, <em>(TriangularPolar2D_Vertex)arg2</em>, <em>(TriangularPolar2D_Vertex)arg3</em>, <em>(TriangularPolar2D_Vertex)arg4</em><big>)</big> &rarr; TriangularPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularPolar2D_Cell make_cell(TriangularPolar2D_Segment {lvalue},TriangularPolar2D_Vertex,TriangularPolar2D_Vertex,TriangularPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TriangularSpherical3D_Segment)arg1</em>, <em>(TriangularSpherical3D_Vertex)arg2</em>, <em>(TriangularSpherical3D_Vertex)arg3</em>, <em>(TriangularSpherical3D_Vertex)arg4</em><big>)</big> &rarr; TriangularSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TriangularSpherical3D_Cell make_cell(TriangularSpherical3D_Segment {lvalue},TriangularSpherical3D_Vertex,TriangularSpherical3D_Vertex,TriangularSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCartesian2D_Segment)arg1</em>, <em>(QuadrilateralCartesian2D_Vertex)arg2</em>, <em>(QuadrilateralCartesian2D_Vertex)arg3</em>, <em>(QuadrilateralCartesian2D_Vertex)arg4</em>, <em>(QuadrilateralCartesian2D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCartesian2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian2D_Cell make_cell(QuadrilateralCartesian2D_Segment {lvalue},QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex,QuadrilateralCartesian2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCartesian3D_Segment)arg1</em>, <em>(QuadrilateralCartesian3D_Vertex)arg2</em>, <em>(QuadrilateralCartesian3D_Vertex)arg3</em>, <em>(QuadrilateralCartesian3D_Vertex)arg4</em>, <em>(QuadrilateralCartesian3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCartesian3D_Cell make_cell(QuadrilateralCartesian3D_Segment {lvalue},QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex,QuadrilateralCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralCylindrical3D_Segment)arg1</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg2</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg3</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg4</em>, <em>(QuadrilateralCylindrical3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralCylindrical3D_Cell make_cell(QuadrilateralCylindrical3D_Segment {lvalue},QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex,QuadrilateralCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralPolar2D_Segment)arg1</em>, <em>(QuadrilateralPolar2D_Vertex)arg2</em>, <em>(QuadrilateralPolar2D_Vertex)arg3</em>, <em>(QuadrilateralPolar2D_Vertex)arg4</em>, <em>(QuadrilateralPolar2D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralPolar2D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralPolar2D_Cell make_cell(QuadrilateralPolar2D_Segment {lvalue},QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex,QuadrilateralPolar2D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(QuadrilateralSpherical3D_Segment)arg1</em>, <em>(QuadrilateralSpherical3D_Vertex)arg2</em>, <em>(QuadrilateralSpherical3D_Vertex)arg3</em>, <em>(QuadrilateralSpherical3D_Vertex)arg4</em>, <em>(QuadrilateralSpherical3D_Vertex)arg5</em><big>)</big> &rarr; QuadrilateralSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>QuadrilateralSpherical3D_Cell make_cell(QuadrilateralSpherical3D_Segment {lvalue},QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex,QuadrilateralSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralCartesian3D_Segment)arg1</em>, <em>(TetrahedralCartesian3D_Vertex)arg2</em>, <em>(TetrahedralCartesian3D_Vertex)arg3</em>, <em>(TetrahedralCartesian3D_Vertex)arg4</em>, <em>(TetrahedralCartesian3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralCartesian3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCartesian3D_Cell make_cell(TetrahedralCartesian3D_Segment {lvalue},TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex,TetrahedralCartesian3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralCylindrical3D_Segment)arg1</em>, <em>(TetrahedralCylindrical3D_Vertex)arg2</em>, <em>(TetrahedralCylindrical3D_Vertex)arg3</em>, <em>(TetrahedralCylindrical3D_Vertex)arg4</em>, <em>(TetrahedralCylindrical3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralCylindrical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralCylindrical3D_Cell make_cell(TetrahedralCylindrical3D_Segment {lvalue},TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex,TetrahedralCylindrical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segment">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Segment</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segment.cells">
<tt class="descname">cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segment.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the cells stored within the segment.</p>
</dd></dl>

<dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segment.make_cell">
<tt class="descname">make_cell</tt><big>(</big><em>(TetrahedralSpherical3D_Segment)arg1</em>, <em>(TetrahedralSpherical3D_Vertex)arg2</em>, <em>(TetrahedralSpherical3D_Vertex)arg3</em>, <em>(TetrahedralSpherical3D_Vertex)arg4</em>, <em>(TetrahedralSpherical3D_Vertex)arg5</em><big>)</big> &rarr; TetrahedralSpherical3D_Cell :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segment.make_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cell within the segment, taking the vertices of the cell as arguments.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>TetrahedralSpherical3D_Cell make_cell(TetrahedralSpherical3D_Segment {lvalue},TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex,TetrahedralSpherical3D_Vertex)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Segment.num_cells">
<tt class="descname">num_cells</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Segment.num_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of cells in the segment.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cells">
<h2>4.2.5. Cells<a class="headerlink" href="#cells" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian1D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCartesian3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearPolar2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.LinearSpherical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularPolar2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Cell">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Cell</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Cell" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Cell.edges">
<tt class="descname">edges</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Cell.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the edges that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Cell.facets">
<tt class="descname">facets</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Cell.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the facets that form the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Cell.num_vertices">
<tt class="descname">num_vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Cell.num_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns the number of vertices that define the cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Cell.vertices">
<tt class="descname">vertices</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Cell.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only property that returns a list containing all the vertices that define the cell.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="vertices">
<h2>4.2.6. Vertices<a class="headerlink" href="#vertices" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian1D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearCartesian1D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian1D :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian1D to_point(LinearCartesian1D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearCartesian2D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian2D :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D to_point(LinearCartesian2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCartesian3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearCartesian3D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_point(LinearCartesian3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearCylindrical3D_Vertex)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_point(LinearCylindrical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearPolar2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearPolar2D_Vertex)arg1</em><big>)</big> &rarr; PointPolar2D :<a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D to_point(LinearPolar2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.LinearSpherical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(LinearSpherical3D_Vertex)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_point(LinearSpherical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TriangularCartesian2D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian2D :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D to_point(TriangularCartesian2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TriangularCartesian3D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_point(TriangularCartesian3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TriangularCylindrical3D_Vertex)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_point(TriangularCylindrical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularPolar2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TriangularPolar2D_Vertex)arg1</em><big>)</big> &rarr; PointPolar2D :<a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D to_point(TriangularPolar2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TriangularSpherical3D_Vertex)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_point(TriangularSpherical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(QuadrilateralCartesian2D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian2D :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D to_point(QuadrilateralCartesian2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(QuadrilateralCartesian3D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_point(QuadrilateralCartesian3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(QuadrilateralCylindrical3D_Vertex)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_point(QuadrilateralCylindrical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(QuadrilateralPolar2D_Vertex)arg1</em><big>)</big> &rarr; PointPolar2D :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D to_point(QuadrilateralPolar2D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(QuadrilateralSpherical3D_Vertex)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_point(QuadrilateralSpherical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TetrahedralCartesian3D_Vertex)arg1</em><big>)</big> &rarr; PointCartesian3D :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D to_point(TetrahedralCartesian3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TetrahedralCylindrical3D_Vertex)arg1</em><big>)</big> &rarr; PointCylindrical3D :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D to_point(TetrahedralCylindrical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Vertex">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Vertex</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Vertex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Vertex.to_point">
<tt class="descname">to_point</tt><big>(</big><em>(TetrahedralSpherical3D_Vertex)arg1</em><big>)</big> &rarr; PointSpherical3D :<a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Vertex.to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the vertex object to a point object.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D to_point(TetrahedralSpherical3D_Vertex {lvalue})</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="facets">
<h2>4.2.7. Facets<a class="headerlink" href="#facets" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Facet">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Facet</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Facet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="edges">
<h2>4.2.8. Edges<a class="headerlink" href="#edges" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian1D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian1D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian1D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCartesian3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCartesian3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCartesian3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearCylindrical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearCylindrical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearCylindrical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearPolar2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearPolar2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearPolar2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.LinearSpherical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">LinearSpherical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.LinearSpherical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCartesian3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCartesian3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCartesian3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularCylindrical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularCylindrical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularCylindrical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularPolar2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularPolar2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularPolar2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TriangularSpherical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TriangularSpherical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TriangularSpherical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCartesian3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCartesian3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCartesian3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralCylindrical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralCylindrical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralCylindrical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralPolar2D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralPolar2D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralPolar2D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.QuadrilateralSpherical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">QuadrilateralSpherical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.QuadrilateralSpherical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCartesian3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCartesian3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCartesian3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralCylindrical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralCylindrical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralCylindrical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="viennagrid.wrapper.TetrahedralSpherical3D_Edge">
<em class="property">class </em><tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">TetrahedralSpherical3D_Edge</tt><a class="headerlink" href="#viennagrid.wrapper.TetrahedralSpherical3D_Edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="free-functions">
<h2>4.2.9. Free functions<a class="headerlink" href="#free-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="viennagrid.wrapper.version">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">version</tt><big>(</big><big>)</big> &rarr; str :<a class="headerlink" href="#viennagrid.wrapper.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the version number of the wrapper.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>char const* version()</dd>
</dl>
</dd></dl>

<div class="section" id="input-output-functions">
<h3>4.2.9.1. Input/output functions<a class="headerlink" href="#input-output-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="viennagrid.wrapper.read_netgen">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">read_netgen</tt><big>(</big><em>(str)filename</em>, <em>(LinearCartesian1D_Domain)domain</em><span class="optional">[</span>, <em>(object)segmentation</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.read_netgen" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Read mesh data from a Netgen file.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearCartesian1D_Domain [,boost::python::api::object])</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>read_netgen( (str)filename, (LinearCartesian2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearCartesian2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (LinearCartesian3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearCartesian3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (LinearCylindrical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearCylindrical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (LinearPolar2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearPolar2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (LinearSpherical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,LinearSpherical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TriangularCartesian2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TriangularCartesian2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TriangularCartesian3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TriangularCartesian3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TriangularCylindrical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TriangularCylindrical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TriangularPolar2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TriangularPolar2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TriangularSpherical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TriangularSpherical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (QuadrilateralCartesian2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,QuadrilateralCartesian2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (QuadrilateralCartesian3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,QuadrilateralCartesian3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (QuadrilateralCylindrical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,QuadrilateralCylindrical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (QuadrilateralPolar2D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,QuadrilateralPolar2D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (QuadrilateralSpherical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,QuadrilateralSpherical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TetrahedralCartesian3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TetrahedralCartesian3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TetrahedralCylindrical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TetrahedralCylindrical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
<dt>read_netgen( (str)filename, (TetrahedralSpherical3D_Domain)domain [, (object)segmentation]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a Netgen file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_netgen(boost::python::str,TetrahedralSpherical3D_Domain [,boost::python::api::object])</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.read_vtk">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">read_vtk</tt><big>(</big><em>(str)filename</em>, <em>(LinearCartesian1D_Domain)domain</em><span class="optional">[</span>, <em>(object)segmentation</em><span class="optional">[</span>, <em>(dict)accessors</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.read_vtk" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Read mesh data from a VTK file.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearCartesian1D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>read_vtk( (str)filename, (LinearCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (LinearCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (LinearCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (LinearPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (LinearSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,LinearSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TriangularCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TriangularCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TriangularCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TriangularCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TriangularCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TriangularCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TriangularPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TriangularPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TriangularSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TriangularSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (QuadrilateralCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,QuadrilateralCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (QuadrilateralCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,QuadrilateralCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (QuadrilateralCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,QuadrilateralCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (QuadrilateralPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,QuadrilateralPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (QuadrilateralSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,QuadrilateralSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TetrahedralCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TetrahedralCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TetrahedralCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TetrahedralCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>read_vtk( (str)filename, (TetrahedralSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Read mesh data from a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void read_vtk(boost::python::str,TetrahedralSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.write_opendx">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">write_opendx</tt><big>(</big><em>(str)filename</em>, <em>(LinearCartesian1D_Domain)domain</em><span class="optional">[</span>, <em>(dict)accessors</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.write_opendx" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Write mesh data to an OpenDX file.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearCartesian1D_Domain [,boost::python::dict])</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>write_opendx( (str)filename, (LinearCartesian2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearCartesian2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (LinearCartesian3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearCartesian3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (LinearCylindrical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearCylindrical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (LinearPolar2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearPolar2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (LinearSpherical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,LinearSpherical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TriangularCartesian2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TriangularCartesian2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TriangularCartesian3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TriangularCartesian3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TriangularCylindrical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TriangularCylindrical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TriangularPolar2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TriangularPolar2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TriangularSpherical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TriangularSpherical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (QuadrilateralCartesian2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,QuadrilateralCartesian2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (QuadrilateralCartesian3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,QuadrilateralCartesian3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (QuadrilateralCylindrical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,QuadrilateralCylindrical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (QuadrilateralPolar2D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,QuadrilateralPolar2D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (QuadrilateralSpherical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,QuadrilateralSpherical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TetrahedralCartesian3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TetrahedralCartesian3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TetrahedralCylindrical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TetrahedralCylindrical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
<dt>write_opendx( (str)filename, (TetrahedralSpherical3D_Domain)domain [, (dict)accessors]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to an OpenDX file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_opendx(boost::python::str,TetrahedralSpherical3D_Domain [,boost::python::dict])</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.write_vtk">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">write_vtk</tt><big>(</big><em>(str)filename</em>, <em>(LinearCartesian1D_Domain)domain</em><span class="optional">[</span>, <em>(object)segmentation</em><span class="optional">[</span>, <em>(dict)accessors</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.write_vtk" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Write mesh data to a VTK file.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearCartesian1D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>write_vtk( (str)filename, (LinearCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (LinearCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (LinearCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (LinearPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (LinearSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,LinearSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TriangularCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TriangularCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TriangularCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TriangularCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TriangularCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TriangularCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TriangularPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TriangularPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TriangularSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TriangularSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (QuadrilateralCartesian2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,QuadrilateralCartesian2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (QuadrilateralCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,QuadrilateralCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (QuadrilateralCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,QuadrilateralCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (QuadrilateralPolar2D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,QuadrilateralPolar2D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (QuadrilateralSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,QuadrilateralSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TetrahedralCartesian3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TetrahedralCartesian3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TetrahedralCylindrical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TetrahedralCylindrical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
<dt>write_vtk( (str)filename, (TetrahedralSpherical3D_Domain)domain [, (object)segmentation [, (dict)accessors]]) -&gt; None :</dt>
<dd><p class="first">Write mesh data to a VTK file.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void write_vtk(boost::python::str,TetrahedralSpherical3D_Domain [,boost::python::api::object [,boost::python::dict]])</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="algorithms">
<h3>4.2.9.2. Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="viennagrid.wrapper.apply_voronoi">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">apply_voronoi</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.apply_voronoi" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute Voronoi information of the given domain.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearCartesian1D_Domain)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>apply_voronoi( (LinearCartesian2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (LinearCartesian3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (LinearCylindrical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (LinearPolar2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearPolar2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (LinearSpherical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(LinearSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TriangularCartesian2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TriangularCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TriangularCartesian3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TriangularCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TriangularCylindrical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TriangularCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TriangularPolar2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TriangularPolar2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TriangularSpherical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TriangularSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (QuadrilateralCartesian2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(QuadrilateralCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (QuadrilateralCartesian3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(QuadrilateralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (QuadrilateralCylindrical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(QuadrilateralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (QuadrilateralPolar2D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(QuadrilateralPolar2D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (QuadrilateralSpherical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(QuadrilateralSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TetrahedralCartesian3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TetrahedralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TetrahedralCylindrical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TetrahedralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>apply_voronoi( (TetrahedralSpherical3D_Domain)arg1) -&gt; None :</dt>
<dd><p class="first">Compute Voronoi information of the given domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void apply_voronoi(TetrahedralSpherical3D_Domain)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.cell_refine">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">cell_refine</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(TriangularCartesian2D_Segmentation)arg2</em>, <em>(object)arg3</em><big>)</big> &rarr; tuple :<a class="headerlink" href="#viennagrid.wrapper.cell_refine" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TriangularCartesian2D_Domain,TriangularCartesian2D_Segmentation,boost::python::api::object)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>cell_refine( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TriangularCartesian3D_Domain,TriangularCartesian3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TriangularPolar2D_Domain,TriangularPolar2D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TriangularSpherical3D_Domain,TriangularSpherical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>cell_refine( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all cells of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple cell_refine(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.centroid">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">centroid</tt><big>(</big><em>(LinearCartesian1D_Cell)arg1</em><big>)</big> &rarr; PointCartesian1D :<a class="headerlink" href="#viennagrid.wrapper.centroid" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute the centroid of a cell.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian1D centroid(LinearCartesian1D_Cell)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>centroid( (LinearCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D centroid(LinearCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (LinearCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D centroid(LinearCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (LinearCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D centroid(LinearCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (LinearPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D centroid(LinearPolar2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (LinearSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D centroid(LinearSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TriangularCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D centroid(TriangularCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TriangularCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D centroid(TriangularCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TriangularCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D centroid(TriangularCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TriangularPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D centroid(TriangularPolar2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TriangularSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D centroid(TriangularSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (QuadrilateralCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D centroid(QuadrilateralCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (QuadrilateralCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D centroid(QuadrilateralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (QuadrilateralCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D centroid(QuadrilateralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (QuadrilateralPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D centroid(QuadrilateralPolar2D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (QuadrilateralSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D centroid(QuadrilateralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TetrahedralCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D centroid(TetrahedralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TetrahedralCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D centroid(TetrahedralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>centroid( (TetrahedralSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the centroid of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D centroid(TetrahedralSpherical3D_Cell)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.circumcenter">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">circumcenter</tt><big>(</big><em>(LinearCartesian1D_Cell)arg1</em><big>)</big> &rarr; PointCartesian1D :<a class="headerlink" href="#viennagrid.wrapper.circumcenter" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute the circumcenter of a cell.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian1D circumcenter(LinearCartesian1D_Cell)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>circumcenter( (LinearCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D circumcenter(LinearCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (LinearCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D circumcenter(LinearCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (LinearCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D circumcenter(LinearCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (LinearPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D circumcenter(LinearPolar2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (LinearSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D circumcenter(LinearSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TriangularCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D circumcenter(TriangularCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TriangularCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D circumcenter(TriangularCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TriangularCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D circumcenter(TriangularCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TriangularPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D circumcenter(TriangularPolar2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TriangularSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D circumcenter(TriangularSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (QuadrilateralCartesian2D_Cell)arg1) -&gt; PointCartesian2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian2D circumcenter(QuadrilateralCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (QuadrilateralCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D circumcenter(QuadrilateralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (QuadrilateralCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D circumcenter(QuadrilateralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (QuadrilateralPolar2D_Cell)arg1) -&gt; PointPolar2D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointPolar2D circumcenter(QuadrilateralPolar2D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (QuadrilateralSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D circumcenter(QuadrilateralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TetrahedralCartesian3D_Cell)arg1) -&gt; PointCartesian3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCartesian3D circumcenter(TetrahedralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TetrahedralCylindrical3D_Cell)arg1) -&gt; PointCylindrical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointCylindrical3D circumcenter(TetrahedralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>circumcenter( (TetrahedralSpherical3D_Cell)arg1) -&gt; PointSpherical3D :</dt>
<dd><p class="first">Compute the circumcenter of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>PointSpherical3D circumcenter(TetrahedralSpherical3D_Cell)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.is_boundary">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">is_boundary</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em>, <em>(LinearCartesian1D_Facet)arg2</em><big>)</big> &rarr; bool :<a class="headerlink" href="#viennagrid.wrapper.is_boundary" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian1D_Domain,LinearCartesian1D_Facet)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>is_boundary( (LinearCartesian2D_Domain)arg1, (LinearCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian2D_Domain,LinearCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian3D_Domain)arg1, (LinearCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian3D_Domain,LinearCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCylindrical3D_Domain)arg1, (LinearCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCylindrical3D_Domain,LinearCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearPolar2D_Domain)arg1, (LinearPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearPolar2D_Domain,LinearPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearSpherical3D_Domain)arg1, (LinearSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearSpherical3D_Domain,LinearSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Domain)arg1, (TriangularCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Domain,TriangularCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Domain,TriangularCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Domain,TriangularPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Domain,TriangularSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Domain)arg1, (QuadrilateralCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Domain,QuadrilateralCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Domain)arg1, (QuadrilateralCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Domain,QuadrilateralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Domain)arg1, (QuadrilateralCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Domain,QuadrilateralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Domain)arg1, (QuadrilateralPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Domain,QuadrilateralPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Domain)arg1, (QuadrilateralSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Domain,QuadrilateralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Domain)arg1, (TriangularCartesian2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Domain,TriangularCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Domain,TriangularCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Domain,TriangularPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Domain,TriangularSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Domain)arg1, (QuadrilateralCartesian2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Domain,QuadrilateralCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Domain)arg1, (QuadrilateralCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Domain,QuadrilateralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Domain)arg1, (QuadrilateralCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Domain,QuadrilateralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Domain)arg1, (QuadrilateralPolar2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Domain,QuadrilateralPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Domain)arg1, (QuadrilateralSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Domain,QuadrilateralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian1D_Domain)arg1, (LinearCartesian1D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian1D_Domain,LinearCartesian1D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian2D_Domain)arg1, (LinearCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian2D_Domain,LinearCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian3D_Domain)arg1, (LinearCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian3D_Domain,LinearCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCylindrical3D_Domain)arg1, (LinearCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCylindrical3D_Domain,LinearCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearPolar2D_Domain)arg1, (LinearPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearPolar2D_Domain,LinearPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearSpherical3D_Domain)arg1, (LinearSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearSpherical3D_Domain,LinearSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Domain)arg1, (TriangularCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Domain,TriangularCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Domain,TriangularCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Domain,TriangularPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Domain,TriangularSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Domain)arg1, (QuadrilateralCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Domain,QuadrilateralCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Domain)arg1, (QuadrilateralCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Domain,QuadrilateralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Domain)arg1, (QuadrilateralCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Domain,QuadrilateralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Domain)arg1, (QuadrilateralPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Domain,QuadrilateralPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Domain)arg1, (QuadrilateralSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Domain,QuadrilateralSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given domain. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian1D_Segment)arg1, (LinearCartesian1D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian1D_Segment,LinearCartesian1D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian2D_Segment)arg1, (LinearCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian2D_Segment,LinearCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian3D_Segment)arg1, (LinearCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian3D_Segment,LinearCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCylindrical3D_Segment)arg1, (LinearCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCylindrical3D_Segment,LinearCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearPolar2D_Segment)arg1, (LinearPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearPolar2D_Segment,LinearPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearSpherical3D_Segment)arg1, (LinearSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearSpherical3D_Segment,LinearSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Segment,TriangularCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Segment,TriangularCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Segment,TriangularPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Segment,TriangularSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Facet)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Segment,TriangularCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Segment,TriangularCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Segment,TriangularPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Segment,TriangularSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Edge)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian1D_Segment)arg1, (LinearCartesian1D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian1D_Segment,LinearCartesian1D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian2D_Segment)arg1, (LinearCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian2D_Segment,LinearCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCartesian3D_Segment)arg1, (LinearCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCartesian3D_Segment,LinearCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearCylindrical3D_Segment)arg1, (LinearCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearCylindrical3D_Segment,LinearCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearPolar2D_Segment)arg1, (LinearPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearPolar2D_Segment,LinearPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (LinearSpherical3D_Segment)arg1, (LinearSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(LinearSpherical3D_Segment,LinearSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian2D_Segment,TriangularCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCartesian3D_Segment,TriangularCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularPolar2D_Segment,TriangularPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TriangularSpherical3D_Segment,TriangularSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_boundary( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Vertex)arg2) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is a boundary element of the given segment. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_boundary(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Vertex)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.is_interface">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">is_interface</tt><big>(</big><em>(LinearCartesian1D_Segment)arg1</em>, <em>(LinearCartesian1D_Segment)arg2</em>, <em>(LinearCartesian1D_Facet)arg3</em><big>)</big> &rarr; bool :<a class="headerlink" href="#viennagrid.wrapper.is_interface" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian1D_Segment,LinearCartesian1D_Segment,LinearCartesian1D_Facet)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>is_interface( (LinearCartesian2D_Segment)arg1, (LinearCartesian2D_Segment)arg2, (LinearCartesian2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian2D_Segment,LinearCartesian2D_Segment,LinearCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCartesian3D_Segment)arg1, (LinearCartesian3D_Segment)arg2, (LinearCartesian3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian3D_Segment,LinearCartesian3D_Segment,LinearCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCylindrical3D_Segment)arg1, (LinearCylindrical3D_Segment)arg2, (LinearCylindrical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCylindrical3D_Segment,LinearCylindrical3D_Segment,LinearCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (LinearPolar2D_Segment)arg1, (LinearPolar2D_Segment)arg2, (LinearPolar2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearPolar2D_Segment,LinearPolar2D_Segment,LinearPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (LinearSpherical3D_Segment)arg1, (LinearSpherical3D_Segment)arg2, (LinearSpherical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearSpherical3D_Segment,LinearSpherical3D_Segment,LinearSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Segment)arg2, (TriangularCartesian2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian2D_Segment,TriangularCartesian2D_Segment,TriangularCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Segment)arg2, (TriangularCartesian3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian3D_Segment,TriangularCartesian3D_Segment,TriangularCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Segment)arg2, (TriangularCylindrical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Segment,TriangularCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Segment)arg2, (TriangularPolar2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularPolar2D_Segment,TriangularPolar2D_Segment,TriangularPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Segment)arg2, (TriangularSpherical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularSpherical3D_Segment,TriangularSpherical3D_Segment,TriangularSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Segment)arg2, (QuadrilateralCartesian2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Segment)arg2, (QuadrilateralCartesian3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Segment)arg2, (QuadrilateralCylindrical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Segment)arg2, (QuadrilateralPolar2D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Segment)arg2, (QuadrilateralSpherical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Segment)arg2, (TetrahedralCartesian3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Segment)arg2, (TetrahedralCylindrical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Segment)arg2, (TetrahedralSpherical3D_Facet)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given facet is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Facet)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Segment)arg2, (TriangularCartesian2D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian2D_Segment,TriangularCartesian2D_Segment,TriangularCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Segment)arg2, (TriangularCartesian3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian3D_Segment,TriangularCartesian3D_Segment,TriangularCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Segment)arg2, (TriangularCylindrical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Segment,TriangularCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Segment)arg2, (TriangularPolar2D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularPolar2D_Segment,TriangularPolar2D_Segment,TriangularPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Segment)arg2, (TriangularSpherical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularSpherical3D_Segment,TriangularSpherical3D_Segment,TriangularSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Segment)arg2, (QuadrilateralCartesian2D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Segment)arg2, (QuadrilateralCartesian3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Segment)arg2, (QuadrilateralCylindrical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Segment)arg2, (QuadrilateralPolar2D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Segment)arg2, (QuadrilateralSpherical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Segment)arg2, (TetrahedralCartesian3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Segment)arg2, (TetrahedralCylindrical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Segment)arg2, (TetrahedralSpherical3D_Edge)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given edge is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Edge)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCartesian1D_Segment)arg1, (LinearCartesian1D_Segment)arg2, (LinearCartesian1D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian1D_Segment,LinearCartesian1D_Segment,LinearCartesian1D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCartesian2D_Segment)arg1, (LinearCartesian2D_Segment)arg2, (LinearCartesian2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian2D_Segment,LinearCartesian2D_Segment,LinearCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCartesian3D_Segment)arg1, (LinearCartesian3D_Segment)arg2, (LinearCartesian3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCartesian3D_Segment,LinearCartesian3D_Segment,LinearCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (LinearCylindrical3D_Segment)arg1, (LinearCylindrical3D_Segment)arg2, (LinearCylindrical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearCylindrical3D_Segment,LinearCylindrical3D_Segment,LinearCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (LinearPolar2D_Segment)arg1, (LinearPolar2D_Segment)arg2, (LinearPolar2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearPolar2D_Segment,LinearPolar2D_Segment,LinearPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (LinearSpherical3D_Segment)arg1, (LinearSpherical3D_Segment)arg2, (LinearSpherical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(LinearSpherical3D_Segment,LinearSpherical3D_Segment,LinearSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian2D_Segment)arg1, (TriangularCartesian2D_Segment)arg2, (TriangularCartesian2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian2D_Segment,TriangularCartesian2D_Segment,TriangularCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCartesian3D_Segment)arg1, (TriangularCartesian3D_Segment)arg2, (TriangularCartesian3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCartesian3D_Segment,TriangularCartesian3D_Segment,TriangularCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularCylindrical3D_Segment)arg1, (TriangularCylindrical3D_Segment)arg2, (TriangularCylindrical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularCylindrical3D_Segment,TriangularCylindrical3D_Segment,TriangularCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularPolar2D_Segment)arg1, (TriangularPolar2D_Segment)arg2, (TriangularPolar2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularPolar2D_Segment,TriangularPolar2D_Segment,TriangularPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TriangularSpherical3D_Segment)arg1, (TriangularSpherical3D_Segment)arg2, (TriangularSpherical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TriangularSpherical3D_Segment,TriangularSpherical3D_Segment,TriangularSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian2D_Segment)arg1, (QuadrilateralCartesian2D_Segment)arg2, (QuadrilateralCartesian2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Segment,QuadrilateralCartesian2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCartesian3D_Segment)arg1, (QuadrilateralCartesian3D_Segment)arg2, (QuadrilateralCartesian3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Segment,QuadrilateralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralCylindrical3D_Segment)arg1, (QuadrilateralCylindrical3D_Segment)arg2, (QuadrilateralCylindrical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Segment,QuadrilateralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralPolar2D_Segment)arg1, (QuadrilateralPolar2D_Segment)arg2, (QuadrilateralPolar2D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Segment,QuadrilateralPolar2D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (QuadrilateralSpherical3D_Segment)arg1, (QuadrilateralSpherical3D_Segment)arg2, (QuadrilateralSpherical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Segment,QuadrilateralSpherical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCartesian3D_Segment)arg1, (TetrahedralCartesian3D_Segment)arg2, (TetrahedralCartesian3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Segment,TetrahedralCartesian3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralCylindrical3D_Segment)arg1, (TetrahedralCylindrical3D_Segment)arg2, (TetrahedralCylindrical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Segment,TetrahedralCylindrical3D_Vertex)</dd>
</dl>
</dd>
<dt>is_interface( (TetrahedralSpherical3D_Segment)arg1, (TetrahedralSpherical3D_Segment)arg2, (TetrahedralSpherical3D_Vertex)arg3) -&gt; bool :</dt>
<dd><p class="first">Return True if the given vertex is an interface element of the given segments. Otherwise, return False.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>bool is_interface(TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Segment,TetrahedralSpherical3D_Vertex)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.refine">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">refine</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(TriangularCartesian2D_Segmentation)arg2</em>, <em>(object)arg3</em><big>)</big> &rarr; tuple :<a class="headerlink" href="#viennagrid.wrapper.refine" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TriangularCartesian2D_Domain,TriangularCartesian2D_Segmentation,boost::python::api::object)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>refine( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TriangularCartesian3D_Domain,TriangularCartesian3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TriangularPolar2D_Domain,TriangularPolar2D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TriangularSpherical3D_Domain,TriangularSpherical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
<dt>refine( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Segmentation)arg2, (object)arg3) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation which match a given predicate.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Segmentation,boost::python::api::object)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.refine_uniformly">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">refine_uniformly</tt><big>(</big><em>(TriangularCartesian2D_Domain)arg1</em>, <em>(TriangularCartesian2D_Segmentation)arg2</em><big>)</big> &rarr; tuple :<a class="headerlink" href="#viennagrid.wrapper.refine_uniformly" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Refine all edges of the given domain and segmentation.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TriangularCartesian2D_Domain,TriangularCartesian2D_Segmentation)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>refine_uniformly( (TriangularCartesian3D_Domain)arg1, (TriangularCartesian3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TriangularCartesian3D_Domain,TriangularCartesian3D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TriangularCylindrical3D_Domain)arg1, (TriangularCylindrical3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TriangularCylindrical3D_Domain,TriangularCylindrical3D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TriangularPolar2D_Domain)arg1, (TriangularPolar2D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TriangularPolar2D_Domain,TriangularPolar2D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TriangularSpherical3D_Domain)arg1, (TriangularSpherical3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TriangularSpherical3D_Domain,TriangularSpherical3D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TetrahedralCartesian3D_Domain)arg1, (TetrahedralCartesian3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TetrahedralCartesian3D_Domain,TetrahedralCartesian3D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TetrahedralCylindrical3D_Domain)arg1, (TetrahedralCylindrical3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TetrahedralCylindrical3D_Domain,TetrahedralCylindrical3D_Segmentation)</dd>
</dl>
</dd>
<dt>refine_uniformly( (TetrahedralSpherical3D_Domain)arg1, (TetrahedralSpherical3D_Segmentation)arg2) -&gt; tuple :</dt>
<dd><p class="first">Refine all edges of the given domain and segmentation.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>boost::python::tuple refine_uniformly(TetrahedralSpherical3D_Domain,TetrahedralSpherical3D_Segmentation)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.scale">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">scale</tt><big>(</big><em>(LinearCartesian1D_Domain)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; None :<a class="headerlink" href="#viennagrid.wrapper.scale" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Scale a domain by a given factor.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearCartesian1D_Domain,double)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>scale( (LinearCartesian2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearCartesian2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (LinearCartesian3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearCartesian3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (LinearCylindrical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearCylindrical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (LinearPolar2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearPolar2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (LinearSpherical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(LinearSpherical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TriangularCartesian2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TriangularCartesian2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TriangularCartesian3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TriangularCartesian3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TriangularCylindrical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TriangularCylindrical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TriangularPolar2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TriangularPolar2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TriangularSpherical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TriangularSpherical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (QuadrilateralCartesian2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(QuadrilateralCartesian2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (QuadrilateralCartesian3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(QuadrilateralCartesian3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (QuadrilateralCylindrical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(QuadrilateralCylindrical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (QuadrilateralPolar2D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(QuadrilateralPolar2D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (QuadrilateralSpherical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(QuadrilateralSpherical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TetrahedralCartesian3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TetrahedralCartesian3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TetrahedralCylindrical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TetrahedralCylindrical3D_Domain,double)</dd>
</dl>
</dd>
<dt>scale( (TetrahedralSpherical3D_Domain)arg1, (float)arg2) -&gt; None :</dt>
<dd><p class="first">Scale a domain by a given factor.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>void scale(TetrahedralSpherical3D_Domain,double)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.spanned_volume">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">spanned_volume</tt><big>(</big><em>(PointCartesian1D)arg1</em>, <em>(PointCartesian1D)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.spanned_volume" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the volume spanned by a set of points.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian1D,PointCartesian1D)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>spanned_volume( (PointCartesian2D)arg1, (PointCartesian2D)arg2) -&gt; float :</dt>
<dd><p class="first">Calculate the volume spanned by a set of points.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian2D,PointCartesian2D)</dd>
</dl>
</dd>
<dt>spanned_volume( (PointCartesian3D)arg1, (PointCartesian3D)arg2) -&gt; float :</dt>
<dd><p class="first">Calculate the volume spanned by a set of points.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian3D,PointCartesian3D)</dd>
</dl>
</dd>
<dt>spanned_volume( (PointCartesian2D)arg1, (PointCartesian2D)arg2, (PointCartesian2D)arg3) -&gt; float :</dt>
<dd><p class="first">Calculate the volume spanned by a set of points.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian2D,PointCartesian2D,PointCartesian2D)</dd>
</dl>
</dd>
<dt>spanned_volume( (PointCartesian3D)arg1, (PointCartesian3D)arg2, (PointCartesian3D)arg3) -&gt; float :</dt>
<dd><p class="first">Calculate the volume spanned by a set of points.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian3D,PointCartesian3D,PointCartesian3D)</dd>
</dl>
</dd>
<dt>spanned_volume( (PointCartesian3D)arg1, (PointCartesian3D)arg2, (PointCartesian3D)arg3, (PointCartesian3D)arg4) -&gt; float :</dt>
<dd><p class="first">Calculate the volume spanned by a set of points.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double spanned_volume(PointCartesian3D,PointCartesian3D,PointCartesian3D,PointCartesian3D)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.surface">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">surface</tt><big>(</big><em>(LinearCartesian1D_Cell)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.surface" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the surface of a cell.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian1D_Cell)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>surface( (LinearCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (LinearCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (LinearPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearPolar2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (LinearSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TriangularCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TriangularPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularPolar2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TriangularSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralPolar2D_Cell)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian1D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian1D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearPolar2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TriangularCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TriangularPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularPolar2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TriangularSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralPolar2D_Domain)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian1D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian1D_Segment)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (LinearCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (LinearCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (LinearPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearPolar2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (LinearSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(LinearSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TriangularCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TriangularCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TriangularPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularPolar2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TriangularSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TriangularSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralPolar2D_Segment)</dd>
</dl>
</dd>
<dt>surface( (QuadrilateralSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(QuadrilateralSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>surface( (TetrahedralSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the surface of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double surface(TetrahedralSpherical3D_Segment)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="viennagrid.wrapper.volume">
<tt class="descclassname">viennagrid.wrapper.</tt><tt class="descname">volume</tt><big>(</big><em>(LinearCartesian1D_Cell)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#viennagrid.wrapper.volume" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the volume of a cell.</p>
<dl class="docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian1D_Cell)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>volume( (LinearCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (LinearCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (LinearPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearPolar2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (LinearSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TriangularCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TriangularPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularPolar2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TriangularSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralPolar2D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralPolar2D_Cell)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCartesian3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCartesian3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCylindrical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCylindrical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralSpherical3D_Cell)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a cell.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralSpherical3D_Cell)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian1D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian1D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearPolar2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TriangularCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TriangularPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularPolar2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TriangularSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralPolar2D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralPolar2D_Domain)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCartesian3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCartesian3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCylindrical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCylindrical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralSpherical3D_Domain)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of a domain.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralSpherical3D_Domain)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian1D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian1D_Segment)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (LinearCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (LinearCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (LinearPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearPolar2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (LinearSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(LinearSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TriangularCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TriangularCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TriangularPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularPolar2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TriangularSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TriangularSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralPolar2D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralPolar2D_Segment)</dd>
</dl>
</dd>
<dt>volume( (QuadrilateralSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(QuadrilateralSpherical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCartesian3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCartesian3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralCylindrical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralCylindrical3D_Segment)</dd>
</dl>
</dd>
<dt>volume( (TetrahedralSpherical3D_Segment)arg1) -&gt; float :</dt>
<dd><p class="first">Calculate the volume of the given segment.</p>
<dl class="last docutils">
<dt>C++ signature :</dt>
<dd>double volume(TetrahedralSpherical3D_Segment)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.2. API reference of <tt class="docutils literal"><span class="pre">viennagrid.wrapper</span></tt></a><ul>
<li><a class="reference internal" href="#points">4.2.1. Points</a></li>
<li><a class="reference internal" href="#domains">4.2.2. Domains</a></li>
<li><a class="reference internal" href="#segmentations">4.2.3. Segmentations</a></li>
<li><a class="reference internal" href="#segments">4.2.4. Segments</a></li>
<li><a class="reference internal" href="#cells">4.2.5. Cells</a></li>
<li><a class="reference internal" href="#vertices">4.2.6. Vertices</a></li>
<li><a class="reference internal" href="#facets">4.2.7. Facets</a></li>
<li><a class="reference internal" href="#edges">4.2.8. Edges</a></li>
<li><a class="reference internal" href="#free-functions">4.2.9. Free functions</a><ul>
<li><a class="reference internal" href="#input-output-functions">4.2.9.1. Input/output functions</a></li>
<li><a class="reference internal" href="#algorithms">4.2.9.2. Algorithms</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="viennagrid.html"
                        title="previous chapter">4.1. API reference of <tt class="docutils literal docutils literal docutils literal"><span class="pre">viennagrid</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../devguide.html"
                        title="next chapter">5. Developer&#8217;s guide</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/apiref/viennagrid_wrapper.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../devguide.html" title="5. Developer’s guide"
             >next</a> |</li>
        <li class="right" >
          <a href="viennagrid.html" title="4.1. API reference of viennagrid"
             >previous</a> |</li>
        <li><a href="../index.html">ViennaGrid for Python 0.1.0-rc.4 documentation</a> &raquo;</li>
          <li><a href="../apiref.html" >4. API reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Jonan Cruz-Martin.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>